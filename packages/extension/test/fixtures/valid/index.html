<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body>
    <img />
    <script>
      const stylesheetRegex = /<\?\s*xml-stylesheet\s+.*href="(.+?)".*\s*\?>/gi
      const urlRegex = /url\((.*?)\)/gi

      async function loadFont(url) {
        const content = await fetch(url).then(res => {
          // console.log(res.body)
          // console.log(res)
          return res.text()
        })
        console.log(content)
        return content
      }

      function base64Encode(str) {
        var CHARS =
          'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        var out = '',
          i = 0,
          len = str.length,
          c1,
          c2,
          c3
        while (i < len) {
          c1 = str.charCodeAt(i++) & 0xff
          if (i == len) {
            out += CHARS.charAt(c1 >> 2)
            out += CHARS.charAt((c1 & 0x3) << 4)
            out += '=='
            break
          }
          c2 = str.charCodeAt(i++)
          if (i == len) {
            out += CHARS.charAt(c1 >> 2)
            out += CHARS.charAt(((c1 & 0x3) << 4) | ((c2 & 0xf0) >> 4))
            out += CHARS.charAt((c2 & 0xf) << 2)
            out += '='
            break
          }
          c3 = str.charCodeAt(i++)
          out += CHARS.charAt(c1 >> 2)
          out += CHARS.charAt(((c1 & 0x3) << 4) | ((c2 & 0xf0) >> 4))
          out += CHARS.charAt(((c2 & 0xf) << 2) | ((c3 & 0xc0) >> 6))
          out += CHARS.charAt(c3 & 0x3f)
        }
        return out
      }

      async function loadCss(styleUrls) {
        return (await Promise.all(
          styleUrls.map(async url => {
            try {
              let content
              const isHttp = url.startsWith('http')
              if (isHttp) {
                content = await fetch(url).then(response => response.text())
                // console.log(content)
                const urls = (content.match(urlRegex) || []).map(match =>
                  match.replace(urlRegex, '$1')
                )
                // console.log(await loadFont(urls[0]))
                // console.log('HERE')
                for (const url of urls.slice(0, 1)) {
                  const encodedFont = base64Encode(await loadFont(url))
                  content = content.replace(
                    url,
                    `data:font/woff2;charset=utf-8;base64,${encodedFont}'`
                  )
                }
                // console.log(content)
              } else {
                const absolutePath = path.join(path.dirname(state.fsPath), url)
                content = await readFile(absolutePath, 'utf-8')
              }
              return `<style type="text/css"><![CDATA[${content}]]></style>`
            } catch (error) {
              console.error(error)
            }
            return ''
          })
        )).join('')
      }

      /**
       * Inline svg xml stylesheets because otherwise they won't work with html.
       */
      async function inlineSvgStyles(svg) {
        const svgWithoutComments = svg.replace(/<!--(.*?)-->/g, '')
        const styleUrls = (svgWithoutComments.match(stylesheetRegex) || []).map(
          match => match.replace(stylesheetRegex, '$1')
        )
        // console.log(styleUrls)
        const defsEndIndex = svg.toLowerCase().indexOf('</defs>')
        if (defsEndIndex === -1) {
          const svgEndIndex = svg.toLowerCase().indexOf('</svg>')
          return `${svg.slice(0, svgEndIndex)}<defs>${await loadCss(
            styleUrls
          )}</defs>${svg.slice(svgEndIndex, svg.length)}`
        }
        return `${svg.slice(0, defsEndIndex)}${await loadCss(
          styleUrls
        )}${svg.slice(defsEndIndex, svg.length)}`
      }

      const state = {
        content: `<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="https://fonts.googleapis.com/css?family=Lobster" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="300">
<rect fill="black" width="300" height="300"></rect>
<text fill="white" font-family="Lobster, sans-serif" font-size="200" x="60" y="190">J</text>

</svg>
`,
      }
      const $image = document.querySelector('img')

      async function invalidateContent() {
        $image.setAttribute(
          'src',
          `data:image/svg+xml,${encodeURIComponent(
            await inlineSvgStyles(state.content)
          )}`
        )
      }
      invalidateContent()
    </script>
  </body>
</html>
